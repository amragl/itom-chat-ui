#!/bin/bash
# ============================================================================
# itom-chat-ui: Create GitHub Labels and Issues
# Generated by Plan Agent on 2026-02-12
# ============================================================================
# This script creates all required labels and 39 GitHub issues for the
# itom-chat-ui project, then updates the backlog.json with issue numbers.
#
# Usage: bash .agent-forge/scripts/create-github-issues.sh
# ============================================================================

set -e

REPO="amragl/itom-chat-ui"
BACKLOG="/Users/amragl/Python Projects/itom-chat-ui/.agent-forge/plans/backlog.json"

echo "============================================"
echo "Creating GitHub labels for $REPO"
echo "============================================"

gh label create "agent:plan" --repo "$REPO" --color "0E8A16" --description "Created/managed by Plan Agent" --force
gh label create "agent:build" --repo "$REPO" --color "1D76DB" --description "Assigned to Build Agent" --force
gh label create "priority:critical" --repo "$REPO" --color "B60205" --description "Must fix before any other work" --force
gh label create "priority:high" --repo "$REPO" --color "D93F0B" --description "High priority" --force
gh label create "priority:medium" --repo "$REPO" --color "FBCA04" --description "Medium priority" --force
gh label create "priority:low" --repo "$REPO" --color "0E8A16" --description "Low priority" --force
gh label create "type:feature" --repo "$REPO" --color "5319E7" --description "New feature" --force
gh label create "type:bug" --repo "$REPO" --color "B60205" --description "Bug report" --force
gh label create "type:improvement" --repo "$REPO" --color "006B75" --description "Improvement" --force
gh label create "type:tech-debt" --repo "$REPO" --color "E4E669" --description "Technical debt" --force

echo ""
echo "Labels created successfully."
echo ""
echo "============================================"
echo "Creating GitHub issues for $REPO"
echo "============================================"

# Function to create an issue and capture its number
create_issue() {
    local ticket_id="$1"
    local title="$2"
    local body="$3"
    local labels="$4"

    echo "Creating issue: $ticket_id - $title"
    local url
    url=$(gh issue create --repo "$REPO" --title "$ticket_id: $title" --body "$body" --label "$labels")
    local issue_num
    issue_num=$(echo "$url" | grep -o '[0-9]*$')
    echo "  -> Issue #$issue_num created"
    echo "$issue_num"
}

# Track issue numbers for backlog update
declare -a ISSUE_NUMS

# --- Phase 1: Foundation ---

ISSUE_NUMS[1]=$(create_issue "CHAT-001" "Initialize Next.js project with TypeScript and app router" "$(cat <<'BODY'
## Description
Create the Next.js 14+ project with TypeScript, app router, and proper tsconfig. Set up the src/ directory structure with app/, components/, lib/, types/, and hooks/ directories. Configure path aliases (@/ for src/). Include .gitignore for node_modules, .next, and env files.

## Phase
Phase 1: Foundation

## Acceptance Criteria
- [ ] Next.js 14+ project created with TypeScript and app router
- [ ] src/ directory structure: app/, components/, lib/, types/, hooks/
- [ ] Path aliases configured (@/ -> src/)
- [ ] .gitignore includes node_modules, .next, .env*
- [ ] `npm run dev` starts the dev server without errors
- [ ] TypeScript strict mode enabled in tsconfig.json

## Priority: critical | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:critical,type:feature")

ISSUE_NUMS[2]=$(create_issue "CHAT-002" "Configure TailwindCSS with design system tokens" "$(cat <<'BODY'
## Description
Install and configure TailwindCSS v3+ with PostCSS. Define design system tokens in tailwind.config.ts: color palette (primary, secondary, accent, neutral, success, warning, error), typography scale, spacing scale, border radius, and shadow levels. Create a globals.css with base styles and CSS custom properties for theming.

## Phase
Phase 1: Foundation

## Dependencies
- CHAT-001: Initialize Next.js project

## Acceptance Criteria
- [ ] TailwindCSS v3+ installed with PostCSS
- [ ] tailwind.config.ts has complete design system tokens
- [ ] Color palette: primary, secondary, accent, neutral, success, warning, error
- [ ] Typography, spacing, border-radius, and shadow scales defined
- [ ] globals.css with base styles and CSS custom properties
- [ ] Tailwind utility classes working in components

## Priority: high | Complexity: small
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[3]=$(create_issue "CHAT-003" "Set up FastAPI backend with project structure" "$(cat <<'BODY'
## Description
Create the Python FastAPI backend in a backend/ directory. Set up the project structure: backend/app/main.py (FastAPI app), backend/app/routers/ (API route modules), backend/app/models/ (Pydantic models), backend/app/services/ (business logic), backend/app/config.py (settings via pydantic-settings). Include requirements.txt or pyproject.toml with FastAPI, uvicorn, pydantic, and websockets dependencies. Add a health check endpoint at GET /api/health.

## Phase
Phase 1: Foundation

## Acceptance Criteria
- [ ] backend/ directory with proper Python project structure
- [ ] FastAPI app in backend/app/main.py
- [ ] Directory structure: routers/, models/, services/, config.py
- [ ] requirements.txt or pyproject.toml with all dependencies
- [ ] GET /api/health endpoint returns {"status": "ok"}
- [ ] `uvicorn app.main:app --reload` starts without errors

## Priority: critical | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:critical,type:feature")

ISSUE_NUMS[4]=$(create_issue "CHAT-004" "Create application layout shell with sidebar and main content area" "$(cat <<'BODY'
## Description
Build the root layout component with a responsive sidebar (collapsible) and main content area. Sidebar contains: logo/title, navigation links (Chat, Dashboard, Settings), and a conversation list area (placeholder). Main content area uses a flex layout that fills available space. Use TailwindCSS for all styling. The layout must work on desktop (sidebar visible) and mobile (sidebar as drawer).

## Phase
Phase 1: Foundation

## Dependencies
- CHAT-001: Initialize Next.js project
- CHAT-002: Configure TailwindCSS

## Acceptance Criteria
- [ ] Root layout with sidebar and main content area
- [ ] Sidebar: logo/title, navigation links (Chat, Dashboard, Settings)
- [ ] Sidebar: conversation list area (placeholder)
- [ ] Main content fills available space (flex layout)
- [ ] Sidebar collapsible on desktop
- [ ] Sidebar as overlay/drawer on mobile
- [ ] All styling uses TailwindCSS

## Priority: high | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[5]=$(create_issue "CHAT-005" "Configure environment variables and CORS settings" "$(cat <<'BODY'
## Description
Set up environment variable management for both frontend and backend. Frontend: .env.local with NEXT_PUBLIC_API_URL, NEXT_PUBLIC_WS_URL. Backend: .env with ORCHESTRATOR_URL, CORS_ORIGINS, LOG_LEVEL, DATABASE_URL (SQLite path for local dev). Configure CORS middleware in FastAPI to allow the Next.js frontend origin. Create .env.example files for both. Ensure .env files are in .gitignore.

## Phase
Phase 1: Foundation

## Dependencies
- CHAT-001: Initialize Next.js project
- CHAT-003: Set up FastAPI backend

## Acceptance Criteria
- [ ] Frontend .env.local with NEXT_PUBLIC_API_URL and NEXT_PUBLIC_WS_URL
- [ ] Backend .env with ORCHESTRATOR_URL, CORS_ORIGINS, LOG_LEVEL, DATABASE_URL
- [ ] CORS middleware in FastAPI allows Next.js frontend origin
- [ ] .env.example files for both frontend and backend
- [ ] .env files in .gitignore
- [ ] Frontend can reach backend API without CORS errors

## Priority: high | Complexity: small
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[6]=$(create_issue "CHAT-006" "Implement WebSocket infrastructure for real-time communication" "$(cat <<'BODY'
## Description
Set up WebSocket support on both frontend and backend. Backend: Create a WebSocket endpoint at /ws that handles connection lifecycle (connect, disconnect, message). Implement a connection manager class to track active connections and broadcast messages. Frontend: Create a useWebSocket React hook that manages connection state, auto-reconnect with exponential backoff, and message serialization/deserialization (JSON). The hook should expose: connectionStatus, sendMessage, lastMessage, and reconnect.

## Phase
Phase 1: Foundation

## Dependencies
- CHAT-001: Initialize Next.js project
- CHAT-003: Set up FastAPI backend

## Acceptance Criteria
- [ ] Backend WebSocket endpoint at /ws with connect/disconnect/message handling
- [ ] ConnectionManager class tracks active connections and broadcasts
- [ ] Frontend useWebSocket hook with connectionStatus, sendMessage, lastMessage, reconnect
- [ ] Auto-reconnect with exponential backoff
- [ ] JSON message serialization/deserialization
- [ ] Connection status indicator works correctly

## Priority: high | Complexity: large
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[7]=$(create_issue "CHAT-007" "Set up development tooling: ESLint, Prettier, and concurrent dev servers" "$(cat <<'BODY'
## Description
Configure ESLint with TypeScript rules and React hooks plugin. Set up Prettier for consistent formatting. Create a root-level dev script (using concurrently or similar) that starts both the Next.js dev server and the FastAPI uvicorn server simultaneously. Add lint and format scripts to package.json. Configure .eslintrc.json and .prettierrc.

## Phase
Phase 1: Foundation

## Dependencies
- CHAT-001: Initialize Next.js project
- CHAT-003: Set up FastAPI backend

## Acceptance Criteria
- [ ] ESLint configured with TypeScript and React hooks rules
- [ ] Prettier configured with .prettierrc
- [ ] `npm run lint` runs without errors on clean code
- [ ] `npm run format` formats all files
- [ ] `npm run dev` starts both Next.js and FastAPI servers concurrently
- [ ] .eslintrc.json and .prettierrc committed

## Priority: medium | Complexity: small
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

ISSUE_NUMS[8]=$(create_issue "CHAT-008" "Create shared TypeScript type definitions and API client" "$(cat <<'BODY'
## Description
Define core TypeScript interfaces in src/types/: Message (id, role, content, timestamp, agentId, artifacts), Conversation (id, title, messages, createdAt, updatedAt, agentId), Agent (id, name, description, status, icon), Artifact (id, type, title, content, metadata), HealthStatus, WebSocketMessage. Create an API client module in src/lib/api.ts using fetch with proper error handling, base URL configuration, and typed response helpers. This is the single point of contact for all backend API calls.

## Phase
Phase 1: Foundation

## Dependencies
- CHAT-001: Initialize Next.js project

## Acceptance Criteria
- [ ] TypeScript interfaces for Message, Conversation, Agent, Artifact, HealthStatus, WebSocketMessage
- [ ] API client in src/lib/api.ts with typed fetch helpers
- [ ] Base URL from environment variables
- [ ] Proper error handling with typed error responses
- [ ] All API calls go through this client (single point of contact)

## Priority: high | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

# --- Phase 2: Chat Core ---

ISSUE_NUMS[9]=$(create_issue "CHAT-009" "Build message input component with send button and auto-resize" "$(cat <<'BODY'
## Description
Create a MessageInput component with: auto-resizing textarea (grows with content, max 6 lines), send button (enabled only when textarea has content), keyboard shortcut (Enter to send, Shift+Enter for newline), loading state that disables input while waiting for response, and a clear visual design using TailwindCSS. The component accepts an onSend callback prop and manages its own local state.

## Phase
Phase 2: Chat Core

## Dependencies
- CHAT-004: Application layout shell

## Acceptance Criteria
- [ ] Auto-resizing textarea (grows to max 6 lines)
- [ ] Send button enabled only with content
- [ ] Enter sends, Shift+Enter inserts newline
- [ ] Loading state disables input and button
- [ ] Clean TailwindCSS visual design
- [ ] onSend callback prop

## Priority: critical | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:critical,type:feature")

ISSUE_NUMS[10]=$(create_issue "CHAT-010" "Build message display with chat bubbles and agent avatars" "$(cat <<'BODY'
## Description
Create a MessageList component that renders a scrollable list of messages. Each message renders as a ChatBubble component with: different styles for user messages (right-aligned, primary color) vs agent messages (left-aligned, neutral color), agent avatar/icon, agent name label, timestamp, and markdown rendering for message content (using react-markdown or similar). The list auto-scrolls to the bottom on new messages with a scroll-to-bottom button when scrolled up.

## Phase
Phase 2: Chat Core

## Dependencies
- CHAT-004: Application layout shell
- CHAT-008: TypeScript type definitions and API client

## Acceptance Criteria
- [ ] MessageList component with scrollable message list
- [ ] ChatBubble component with user vs agent styling
- [ ] Agent avatar/icon and name label
- [ ] Timestamps on messages
- [ ] Markdown rendering for message content
- [ ] Auto-scroll to bottom on new messages
- [ ] Scroll-to-bottom button when scrolled up

## Priority: critical | Complexity: large
BODY
)" "agent:plan,agent:build,priority:critical,type:feature")

ISSUE_NUMS[11]=$(create_issue "CHAT-011" "Implement streaming response display with typing indicator" "$(cat <<'BODY'
## Description
Add streaming response support so agent replies appear token-by-token. Backend: Create a streaming endpoint POST /api/chat/stream that yields Server-Sent Events (SSE) with partial message chunks. Frontend: Create a useStreamingResponse hook that consumes SSE, accumulates tokens, and exposes the partial message. Show a typing indicator animation (three dots) while waiting for the first token. Handle stream interruption and errors gracefully.

## Phase
Phase 2: Chat Core

## Dependencies
- CHAT-010: Message display with chat bubbles
- CHAT-006: WebSocket infrastructure

## Acceptance Criteria
- [ ] POST /api/chat/stream endpoint yields SSE with partial chunks
- [ ] useStreamingResponse hook consumes SSE and accumulates tokens
- [ ] Typing indicator (three dots animation) before first token
- [ ] Partial message renders in ChatBubble during streaming
- [ ] Stream interruption handled gracefully
- [ ] Error states shown in UI

## Priority: high | Complexity: large
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[12]=$(create_issue "CHAT-012" "Build agent selector component with routing to orchestrator" "$(cat <<'BODY'
## Description
Create an AgentSelector component that displays available ITOM agents (Discovery, Asset, Auditor, Documentator, and auto-route via Orchestrator). Each agent shows: name, icon, short description, and current status (online/offline/busy). The selector appears in the chat header area. When an agent is selected, subsequent messages route to that agent. Backend: Create GET /api/agents endpoint and POST /api/chat/route endpoint.

## Phase
Phase 2: Chat Core

## Dependencies
- CHAT-008: TypeScript type definitions and API client
- CHAT-003: FastAPI backend

## Acceptance Criteria
- [ ] AgentSelector component in chat header
- [ ] Displays all ITOM agents with name, icon, description, status
- [ ] "Auto" option for orchestrator routing
- [ ] GET /api/agents endpoint returns agent list with statuses
- [ ] POST /api/chat/route accepts message and optional agent target
- [ ] Selected agent persists for the conversation

## Priority: high | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[13]=$(create_issue "CHAT-013" "Create FastAPI chat endpoint with orchestrator proxy" "$(cat <<'BODY'
## Description
Implement the core chat API endpoint POST /api/chat that receives a message payload (content, conversationId, agentTarget) and proxies it to the itom-orchestrator MCP server. The endpoint handles: message validation, conversation context assembly, forwarding to orchestrator, receiving and relaying the response, and storing both the user message and agent response. Handle orchestrator connection failures with clear error responses.

## Phase
Phase 2: Chat Core

## Dependencies
- CHAT-003: FastAPI backend
- CHAT-005: Environment variables and CORS

## Acceptance Criteria
- [ ] POST /api/chat endpoint with message payload validation
- [ ] Proxies messages to itom-orchestrator MCP server
- [ ] Assembles conversation context from previous messages
- [ ] Returns agent response with metadata (agent used, response time)
- [ ] Stores user message and agent response
- [ ] Clear error responses for orchestrator connection failures

## Priority: critical | Complexity: large
BODY
)" "agent:plan,agent:build,priority:critical,type:feature")

ISSUE_NUMS[14]=$(create_issue "CHAT-014" "Wire up full chat flow: input to display with WebSocket updates" "$(cat <<'BODY'
## Description
Integrate all chat components into a working end-to-end flow. Create the main Chat page component that composes MessageInput, MessageList, and AgentSelector. Implement chat state management using React context or lightweight state manager. Wire WebSocket for real-time message delivery. Handle the full lifecycle: user types, sends, message appears, typing indicator, streaming response, final message saved.

## Phase
Phase 2: Chat Core

## Dependencies
- CHAT-009: Message input component
- CHAT-010: Message display with chat bubbles
- CHAT-011: Streaming response display
- CHAT-012: Agent selector component
- CHAT-013: FastAPI chat endpoint

## Acceptance Criteria
- [ ] Main Chat page composes all chat components
- [ ] Chat state management (React context or similar)
- [ ] Full lifecycle: type -> send -> display -> typing indicator -> stream -> save
- [ ] WebSocket keeps multiple tabs in sync
- [ ] Error handling for failed messages
- [ ] Smooth, responsive user experience

## Priority: critical | Complexity: large
BODY
)" "agent:plan,agent:build,priority:critical,type:feature")

# --- Phase 3: Conversation Management ---

ISSUE_NUMS[15]=$(create_issue "CHAT-015" "Implement conversation persistence with SQLite backend" "$(cat <<'BODY'
## Description
Create a persistence layer for conversations and messages. Backend: Use SQLite (via aiosqlite) with tables for conversations and messages. Create a DatabaseService class with async CRUD operations. Include database migration setup. Auto-generate conversation titles from the first user message.

## Phase
Phase 3: Conversation Management

## Dependencies
- CHAT-013: FastAPI chat endpoint

## Acceptance Criteria
- [ ] SQLite database with conversations and messages tables
- [ ] DatabaseService class with async CRUD operations
- [ ] create_conversation, get_conversation, list_conversations, delete_conversation
- [ ] add_message, get_messages
- [ ] Database migration setup (version table with SQL scripts)
- [ ] Auto-generated conversation titles from first user message
- [ ] Data persists across server restarts

## Priority: critical | Complexity: large
BODY
)" "agent:plan,agent:build,priority:critical,type:feature")

ISSUE_NUMS[16]=$(create_issue "CHAT-016" "Build conversation list sidebar with create and delete" "$(cat <<'BODY'
## Description
Create a ConversationList component for the sidebar that shows all conversations grouped by date (Today, Yesterday, This Week, Older). Each item shows: title, agent icon, last message preview, timestamp. Include New Conversation button, deletion with confirmation, and active conversation highlighting. Backend: CRUD endpoints for conversations.

## Phase
Phase 3: Conversation Management

## Dependencies
- CHAT-015: Conversation persistence
- CHAT-004: Application layout shell

## Acceptance Criteria
- [ ] ConversationList component in sidebar
- [ ] Conversations grouped by date (Today, Yesterday, This Week, Older)
- [ ] Each item: title, agent icon, last message preview, timestamp
- [ ] New Conversation button
- [ ] Delete with confirmation dialog
- [ ] Active conversation highlighted
- [ ] GET /api/conversations, POST /api/conversations, DELETE /api/conversations/:id

## Priority: high | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[17]=$(create_issue "CHAT-017" "Implement conversation search with full-text matching" "$(cat <<'BODY'
## Description
Add search functionality across all conversations. Backend: Implement full-text search using SQLite FTS5. Frontend: SearchBar component with debounced input, keyboard navigation through results, and highlighted matching text.

## Phase
Phase 3: Conversation Management

## Dependencies
- CHAT-015: Conversation persistence
- CHAT-016: Conversation list sidebar

## Acceptance Criteria
- [ ] SQLite FTS5 full-text search on messages and titles
- [ ] GET /api/conversations/search?q=query endpoint
- [ ] SearchBar component at top of sidebar
- [ ] Results replace conversation list while active
- [ ] Matching text highlighted in results
- [ ] Keyboard navigation (arrow keys) through results
- [ ] 300ms input debounce

## Priority: medium | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

ISSUE_NUMS[18]=$(create_issue "CHAT-018" "Implement context and memory persistence across conversations" "$(cat <<'BODY'
## Description
Add persistent context that carries across conversations with the same agent. Backend: context_memory table and ContextService class. Include relevant context when sending to orchestrator. Frontend: Context Panel (slide-out) showing stored memories per agent with edit/clear options.

## Phase
Phase 3: Conversation Management

## Dependencies
- CHAT-015: Conversation persistence
- CHAT-012: Agent selector component

## Acceptance Criteria
- [ ] context_memory table (agent_id, key, value, updated_at)
- [ ] ContextService with CRUD operations
- [ ] Context included when forwarding to orchestrator
- [ ] GET /api/context/:agentId and PUT /api/context/:agentId endpoints
- [ ] Context Panel (slide-out) in UI
- [ ] Edit and clear context entries
- [ ] Context persists across conversations with same agent

## Priority: medium | Complexity: large
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

ISSUE_NUMS[19]=$(create_issue "CHAT-019" "Add conversation export in multiple formats" "$(cat <<'BODY'
## Description
Allow users to export conversations in JSON, Markdown, and plain text formats. Backend: export endpoint. Frontend: Export button with format dropdown and file download.

## Phase
Phase 3: Conversation Management

## Dependencies
- CHAT-015: Conversation persistence

## Acceptance Criteria
- [ ] GET /api/conversations/:id/export?format=json|md|txt endpoint
- [ ] JSON export with full structured data
- [ ] Markdown export with formatted chat transcript
- [ ] Plain text export
- [ ] Export button in conversation header with format dropdown
- [ ] File download triggered on export
- [ ] Conversation metadata in export header

## Priority: low | Complexity: small
BODY
)" "agent:plan,agent:build,priority:low,type:feature")

# --- Phase 4: Artifact Viewer ---

ISSUE_NUMS[20]=$(create_issue "CHAT-020" "Implement artifact detection and parsing from agent responses" "$(cat <<'BODY'
## Description
Create an artifact detection system that identifies structured output in agent responses. Backend: ArtifactParser service that scans for artifact markers (fenced code blocks, JSON blocks, structured sections). Extract artifacts into typed objects. Store artifacts linked to source messages.

## Phase
Phase 4: Artifact Viewer

## Dependencies
- CHAT-015: Conversation persistence
- CHAT-014: Full chat flow

## Acceptance Criteria
- [ ] ArtifactParser service detects artifacts in agent responses
- [ ] Handles: audit reports, compliance docs, health dashboards, CMDB records, workflow results
- [ ] Extracts into typed Artifact objects (id, type, title, content, metadata)
- [ ] Artifacts stored and linked to source messages
- [ ] Detection works on fenced code blocks, JSON, and structured sections

## Priority: critical | Complexity: large
BODY
)" "agent:plan,agent:build,priority:critical,type:feature")

ISSUE_NUMS[21]=$(create_issue "CHAT-021" "Build inline report viewer for audit and compliance artifacts" "$(cat <<'BODY'
## Description
Create a ReportViewer component for rendering audit reports and compliance documents inline in chat. Support tabular data, key-value displays, collapsible sections, and summary cards. Include maximize button for full-screen view.

## Phase
Phase 4: Artifact Viewer

## Dependencies
- CHAT-020: Artifact detection and parsing

## Acceptance Criteria
- [ ] ReportViewer component renders inline in chat bubbles
- [ ] Sortable tables for tabular data
- [ ] Key-value displays for CMDB records
- [ ] Collapsible sections for documents
- [ ] Summary cards for metric highlights
- [ ] Maximize button for full-screen view
- [ ] Clean, professional TailwindCSS styling

## Priority: high | Complexity: large
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[22]=$(create_issue "CHAT-022" "Build dashboard renderer for health and metrics artifacts" "$(cat <<'BODY'
## Description
Create a DashboardRenderer component for inline health metrics and status dashboards. Render metric cards, status grids, progress bars, and charts (recharts). Support compact and expanded display modes.

## Phase
Phase 4: Artifact Viewer

## Dependencies
- CHAT-020: Artifact detection and parsing

## Acceptance Criteria
- [ ] DashboardRenderer component with metric cards
- [ ] Status grids with colored indicators
- [ ] Progress bars
- [ ] Bar and line charts (recharts)
- [ ] Auto-selects best visualization for data
- [ ] Compact (inline) and expanded (full-width) modes

## Priority: high | Complexity: large
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[23]=$(create_issue "CHAT-023" "Build document viewer for markdown and structured text artifacts" "$(cat <<'BODY'
## Description
Create a DocumentViewer for long-form documents. Support markdown with syntax highlighting, table of contents, collapsible sections, copy-to-clipboard for code, and print-friendly layout. Use react-markdown with remark-gfm.

## Phase
Phase 4: Artifact Viewer

## Dependencies
- CHAT-020: Artifact detection and parsing

## Acceptance Criteria
- [ ] DocumentViewer component for markdown documents
- [ ] Syntax highlighting for code blocks
- [ ] Auto-generated table of contents from headings
- [ ] Collapsible sections
- [ ] Copy-to-clipboard for code blocks
- [ ] Print-friendly layout
- [ ] Reading progress indicator

## Priority: medium | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

ISSUE_NUMS[24]=$(create_issue "CHAT-024" "Implement artifact export and download functionality" "$(cat <<'BODY'
## Description
Add export capabilities for all artifact types. Support JSON, CSV (tabular), PDF (reports/docs), and PNG (dashboards). Backend export endpoint. Frontend export buttons with format options.

## Phase
Phase 4: Artifact Viewer

## Dependencies
- CHAT-021: Inline report viewer
- CHAT-022: Dashboard renderer
- CHAT-023: Document viewer

## Acceptance Criteria
- [ ] GET /api/artifacts/:id/export?format=json|csv|pdf endpoint
- [ ] JSON export for raw artifact data
- [ ] CSV export for tabular data
- [ ] PDF export for reports and documents
- [ ] PNG export for dashboard visualizations
- [ ] Export buttons on each artifact viewer
- [ ] Download progress indicator

## Priority: medium | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

# --- Phase 5: Status Dashboard ---

ISSUE_NUMS[25]=$(create_issue "CHAT-025" "Build agent status panel with connection indicators" "$(cat <<'BODY'
## Description
Create an AgentStatusPanel showing all ITOM agent statuses. Display name, icon, connection status, current activity, last heartbeat, and response latency. Backend endpoint queries orchestrator for real-time status.

## Phase
Phase 5: Status Dashboard

## Dependencies
- CHAT-012: Agent selector component
- CHAT-006: WebSocket infrastructure

## Acceptance Criteria
- [ ] AgentStatusPanel component
- [ ] Per-agent: name, icon, status (online/offline/error), activity, heartbeat, latency
- [ ] GET /api/agents/status endpoint queries orchestrator
- [ ] Refresh button and auto-refresh (30s default)
- [ ] Summary bar: "X of Y agents online"
- [ ] Colored connection indicators

## Priority: high | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[26]=$(create_issue "CHAT-026" "Build workflow progress tracker component" "$(cat <<'BODY'
## Description
Create a WorkflowTracker showing active and recent ITOM workflows. Display workflow name, triggering agent, progress, current step, and status. Backend endpoints query orchestrator for workflow data.

## Phase
Phase 5: Status Dashboard

## Dependencies
- CHAT-003: FastAPI backend
- CHAT-008: TypeScript types and API client

## Acceptance Criteria
- [ ] WorkflowTracker component
- [ ] Shows: name, agent, start time, current step, progress %, status
- [ ] Step-by-step progress visualization
- [ ] GET /api/workflows and GET /api/workflows/:id endpoints
- [ ] Expandable detail views
- [ ] Running/completed/failed status indicators

## Priority: high | Complexity: large
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[27]=$(create_issue "CHAT-027" "Build health metrics display with historical data" "$(cat <<'BODY'
## Description
Create a HealthMetrics component showing system health: overall score, per-agent health, error rates, response time trends, throughput, connections. Use recharts for visualizations. Support time range selection.

## Phase
Phase 5: Status Dashboard

## Dependencies
- CHAT-003: FastAPI backend
- CHAT-008: TypeScript types and API client

## Acceptance Criteria
- [ ] HealthMetrics component
- [ ] Overall and per-agent health scores
- [ ] Error rates (1h, 24h)
- [ ] Response time trend charts (recharts)
- [ ] Throughput bar charts
- [ ] GET /api/health/metrics endpoint
- [ ] Time range selection (1h, 6h, 24h, 7d)

## Priority: medium | Complexity: large
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

ISSUE_NUMS[28]=$(create_issue "CHAT-028" "Implement real-time status updates via WebSocket" "$(cat <<'BODY'
## Description
Extend WebSocket infrastructure for real-time dashboard updates. Backend: /ws/status channel with StatusBroadcaster polling orchestrator. Frontend: useStatusStream hook for live data. Handle reconnection and stale data detection.

## Phase
Phase 5: Status Dashboard

## Dependencies
- CHAT-006: WebSocket infrastructure
- CHAT-025: Agent status panel

## Acceptance Criteria
- [ ] /ws/status WebSocket channel
- [ ] StatusBroadcaster polls orchestrator and pushes changes
- [ ] useStatusStream hook provides live data to dashboard
- [ ] Auto-reconnection on disconnect
- [ ] "Data stale" warning after 60s without update
- [ ] Optimistic UI updates

## Priority: medium | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

ISSUE_NUMS[29]=$(create_issue "CHAT-029" "Create dashboard page layout with navigation and widget arrangement" "$(cat <<'BODY'
## Description
Create the Dashboard page composing AgentStatusPanel, WorkflowTracker, and HealthMetrics. Grid layout with tab navigation (Overview, Agents, Workflows, Health). Quick-action bar. Next.js routing for /dashboard.

## Phase
Phase 5: Status Dashboard

## Dependencies
- CHAT-025: Agent status panel
- CHAT-026: Workflow progress tracker
- CHAT-027: Health metrics display

## Acceptance Criteria
- [ ] Dashboard page with grid layout
- [ ] Tab navigation: Overview, Agents, Workflows, Health
- [ ] Quick-action bar (refresh all, start audit, check health)
- [ ] Next.js routing for /dashboard with sub-routes
- [ ] Responsive grid (3-column desktop, stacks on smaller)
- [ ] All three widgets compose correctly

## Priority: high | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

# --- Phase 6: Polish and UX ---

ISSUE_NUMS[30]=$(create_issue "CHAT-030" "Implement responsive design for mobile and tablet" "$(cat <<'BODY'
## Description
Make entire application responsive. Mobile: sidebar as drawer, full-width chat, stacked dashboard. Tablet: collapsed sidebar, 2-column dashboard. Desktop: full sidebar, 3-column dashboard. Use Tailwind responsive prefixes. Test touch interactions.

## Phase
Phase 6: Polish and UX

## Dependencies
- CHAT-014: Full chat flow
- CHAT-029: Dashboard layout

## Acceptance Criteria
- [ ] Mobile (<640px): drawer sidebar, full-width chat, stacked dashboard
- [ ] Tablet (640-1024px): icon-only sidebar, 2-column dashboard
- [ ] Desktop (>1024px): full sidebar, 3-column dashboard
- [ ] Tailwind responsive prefixes (sm:, md:, lg:)
- [ ] Touch: swipe sidebar, pull to refresh
- [ ] No horizontal scroll at any viewport

## Priority: high | Complexity: large
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[31]=$(create_issue "CHAT-031" "Implement keyboard shortcuts system" "$(cat <<'BODY'
## Description
Create keyboard shortcut system with useKeyboardShortcuts hook. Shortcuts: Cmd/Ctrl+K (search), Cmd/Ctrl+N (new conversation), Cmd/Ctrl+/ (toggle sidebar), Cmd/Ctrl+1-5 (agents), Escape (close), arrows (navigate). Help modal on ? key.

## Phase
Phase 6: Polish and UX

## Dependencies
- CHAT-014: Full chat flow

## Acceptance Criteria
- [ ] useKeyboardShortcuts hook with global registration
- [ ] Cmd/Ctrl+K: quick search, Cmd/Ctrl+N: new conversation
- [ ] Cmd/Ctrl+/: toggle sidebar, Escape: close panels
- [ ] Agent switching with Cmd/Ctrl+1-5
- [ ] Help modal on ? key listing all shortcuts
- [ ] Shortcuts disabled in input fields
- [ ] No conflicts with browser defaults

## Priority: medium | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

ISSUE_NUMS[32]=$(create_issue "CHAT-032" "Implement theme system with light and dark modes" "$(cat <<'BODY'
## Description
Create theme system with light/dark modes and system preference detection. ThemeProvider context with localStorage persistence. Theme toggle in sidebar footer. CSS custom properties for all color tokens. Smooth transition on switch.

## Phase
Phase 6: Polish and UX

## Dependencies
- CHAT-002: TailwindCSS design system
- CHAT-004: Application layout shell

## Acceptance Criteria
- [ ] ThemeProvider context with system preference detection
- [ ] Manual override persisted in localStorage
- [ ] Theme toggle button in sidebar footer
- [ ] All colors use CSS custom properties (no hardcoded)
- [ ] Smooth transition animation on theme switch
- [ ] Light and dark modes fully styled

## Priority: medium | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

ISSUE_NUMS[33]=$(create_issue "CHAT-033" "Implement accessibility: ARIA labels, screen reader support, focus management" "$(cat <<'BODY'
## Description
Comprehensive accessibility audit and enhancement. ARIA roles and labels, focus trapping in modals, heading hierarchy, skip-to-content, WCAG AA color contrast, aria-live regions for dynamic content. Test with VoiceOver and keyboard-only navigation.

## Phase
Phase 6: Polish and UX

## Dependencies
- CHAT-014: Full chat flow
- CHAT-029: Dashboard layout

## Acceptance Criteria
- [ ] ARIA roles and labels on all interactive elements
- [ ] Focus trapping in modals and dialogs
- [ ] Proper heading hierarchy (h1 > h2 > h3)
- [ ] Skip-to-content link
- [ ] WCAG AA color contrast (4.5:1 text, 3:1 large text)
- [ ] aria-live regions for dynamic content
- [ ] All icons and images have alt text
- [ ] Passes keyboard-only navigation test

## Priority: high | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[34]=$(create_issue "CHAT-034" "Polish loading states, error handling UX, and empty states" "$(cat <<'BODY'
## Description
Consistent loading, error, and empty state patterns. Skeleton screens (not spinners) for loading. ErrorBoundary component, toast notifications, inline retry buttons. Empty state designs for all empty views. All states visually polished.

## Phase
Phase 6: Polish and UX

## Dependencies
- CHAT-014: Full chat flow
- CHAT-029: Dashboard layout

## Acceptance Criteria
- [ ] Skeleton screens for conversation list, messages, dashboard panels
- [ ] ErrorBoundary component for React error catching
- [ ] Toast notification system for transient errors
- [ ] Inline error states with retry buttons
- [ ] Empty states: no conversations, no messages, no results, no agents, no workflows
- [ ] All states visually polished with helpful messaging

## Priority: high | Complexity: large
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

# --- Phase 7: Testing and Documentation ---

ISSUE_NUMS[35]=$(create_issue "CHAT-035" "Write frontend unit tests with React Testing Library" "$(cat <<'BODY'
## Description
Set up Jest and React Testing Library. Write unit tests for: MessageInput, MessageList, ChatBubble, AgentSelector, ConversationList, SearchBar. 80% component coverage target. Test utilities and mock providers.

## Phase
Phase 7: Testing and Documentation

## Dependencies
- CHAT-014: Full chat flow
- CHAT-016: Conversation list sidebar

## Acceptance Criteria
- [ ] Jest and React Testing Library configured
- [ ] Tests for MessageInput, MessageList, ChatBubble
- [ ] Tests for AgentSelector, ConversationList, SearchBar
- [ ] Mock providers for theme, WebSocket, API contexts
- [ ] 80% component coverage
- [ ] `npm test` runs all tests

## Priority: high | Complexity: large
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[36]=$(create_issue "CHAT-036" "Write FastAPI integration tests with pytest" "$(cat <<'BODY'
## Description
Set up pytest with httpx AsyncClient. Integration tests for all API endpoints. WebSocket connection tests. SQLite in-memory for test isolation. 90% endpoint coverage.

## Phase
Phase 7: Testing and Documentation

## Dependencies
- CHAT-015: Conversation persistence
- CHAT-013: FastAPI chat endpoint

## Acceptance Criteria
- [ ] pytest with httpx AsyncClient configured
- [ ] Tests for /api/health, /api/chat, /api/conversations, /api/conversations/search
- [ ] Tests for /api/agents, /api/artifacts, /api/workflows, /api/health/metrics
- [ ] WebSocket connection tests (connect, message, disconnect, reconnect)
- [ ] SQLite in-memory for test isolation
- [ ] 90% endpoint coverage

## Priority: high | Complexity: large
BODY
)" "agent:plan,agent:build,priority:high,type:feature")

ISSUE_NUMS[37]=$(create_issue "CHAT-037" "Write E2E tests with Playwright" "$(cat <<'BODY'
## Description
Set up Playwright for E2E testing. Tests for critical flows: send message, create conversation, switch conversations, search, select agent, view artifact, export, dashboard navigation, theme toggle, keyboard shortcuts, responsive layout.

## Phase
Phase 7: Testing and Documentation

## Dependencies
- CHAT-014: Full chat flow
- CHAT-029: Dashboard layout

## Acceptance Criteria
- [ ] Playwright configured with both servers starting
- [ ] E2E tests for all critical user flows
- [ ] Visual regression snapshots for key pages
- [ ] Mobile viewport tests
- [ ] `npx playwright test` runs all E2E tests
- [ ] Tests pass in headless mode

## Priority: medium | Complexity: large
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

ISSUE_NUMS[38]=$(create_issue "CHAT-038" "Generate OpenAPI documentation for FastAPI backend" "$(cat <<'BODY'
## Description
Complete OpenAPI documentation for all endpoints. Detailed docstrings, Pydantic model descriptions with examples, FastAPI metadata, endpoint tags. Verify /docs and /redoc. Export openapi.json.

## Phase
Phase 7: Testing and Documentation

## Dependencies
- CHAT-013: FastAPI chat endpoint
- CHAT-015: Conversation persistence

## Acceptance Criteria
- [ ] All endpoints have detailed docstrings
- [ ] All Pydantic models have field descriptions and examples
- [ ] FastAPI metadata (title, description, version, contact)
- [ ] Endpoint tags (Chat, Conversations, Agents, Artifacts, Workflows, Health)
- [ ] /docs (Swagger UI) complete and accurate
- [ ] /redoc page complete and accurate
- [ ] openapi.json exported

## Priority: medium | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:medium,type:feature")

ISSUE_NUMS[39]=$(create_issue "CHAT-039" "Write user documentation and developer setup guide" "$(cat <<'BODY'
## Description
Create documentation: User Guide (docs/user-guide.md), Developer Guide (docs/developer-guide.md), Architecture doc (docs/architecture.md). Covers usage, setup, project structure, environment variables, API, testing, and deployment.

## Phase
Phase 7: Testing and Documentation

## Acceptance Criteria
- [ ] docs/user-guide.md: overview, features, usage, FAQ
- [ ] docs/developer-guide.md: prerequisites, setup, structure, env vars, API, testing
- [ ] docs/architecture.md: system diagram, communication, WebSocket protocol, orchestrator integration
- [ ] All docs accurate and complete
- [ ] Step-by-step setup instructions verified

## Priority: low | Complexity: medium
BODY
)" "agent:plan,agent:build,priority:low,type:feature")

echo ""
echo "============================================"
echo "All 39 issues created successfully!"
echo "============================================"
echo ""
echo "Issue numbers:"
for i in $(seq 1 39); do
    printf "  CHAT-%03d -> Issue #%s\n" "$i" "${ISSUE_NUMS[$i]}"
done

echo ""
echo "Updating backlog.json with issue numbers..."

# Use python to update the backlog
python3 -c "
import json

backlog_path = '$BACKLOG'
with open(backlog_path, 'r') as f:
    backlog = json.load(f)

issue_map = {
$(for i in $(seq 1 39); do
    printf "    'CHAT-%03d': %s,\n" "$i" "${ISSUE_NUMS[$i]}"
done)
}

for ticket in backlog['tickets']:
    if ticket['id'] in issue_map:
        ticket['github_issue'] = issue_map[ticket['id']]

from datetime import datetime, timezone
backlog['updated_at'] = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%SZ')

with open(backlog_path, 'w') as f:
    json.dump(backlog, f, indent=2)

print('Backlog updated with GitHub issue numbers.')
"

echo ""
echo "Done! All labels, issues, and backlog mappings are complete."
